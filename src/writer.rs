use colored::Colorize;
use std::io::Write;
use std::{
    collections::HashMap,
    fs::{self, File},
    io::{BufRead, BufReader},
    path::Path,
};

use anyhow::Result;

pub fn write_bin(name: String, program: String) -> Option<String> {
    // Up until here the generations have been parsed and we sampled the ones we want.
    // In here we will write each correct sampled generation onto the `bin` dir.

    // Remove problem comments (keep main to compile only)
    let program: String = program
        .lines()
        .filter_map(|line| {
            let trimmed = line.trim_start();
            if trimmed.starts_with("//") || trimmed.is_empty() {
                None
            } else {
                Some(line)
            }
        })
        .collect::<Vec<_>>()
        .join("\n");

    // Create binary path as: projroot/src/bin/<name>.rs
    let bin_path = Path::new("./bin/").join(name.clone() + ".rs");
    if let Some(parent) = bin_path.parent() {
        fs::create_dir_all(parent).ok()?; // src/bin/
    }
    fs::write(&bin_path, program).ok()?;

    // If success we return the path of the binary file
    Some(bin_path.to_string_lossy().to_string())
}

pub fn write_mir_augmented(bin_path: String, mir_map: HashMap<i32, Vec<String>>) {
    // Extract filename
    let filename = Path::new(&bin_path)
        .file_name()
        .expect("Could not extract filename from bin_path")
        .to_string_lossy()
        .into_owned();

    let dest_dir = Path::new("./mir_augmented");
    let dest_path = dest_dir.join(&filename);

    fs::create_dir_all(dest_dir).expect("Failed to create mir_augmented dir");

    let source_file = File::open(&bin_path).expect("Could not open source file");
    let reader = BufReader::new(source_file);
    let mut output_file = File::create(&dest_path).expect("Could not create output file");

    let prompt_path = Path::new("Prompt.txt");
    let prompt_contents = fs::read_to_string(prompt_path).expect("Could not read Prompt.txt");
    // writeln!(output_file, "{}", prompt_contents).unwrap();

    // writeln!(output_file, "```rust").unwrap();
    let mut line_number = 0;
    for (idx, line_result) in reader.lines().enumerate() {
        let line = line_result.expect("Could not read line from source");
        let trimmed = line.trim_start();

        // skip comments in the original script
        if trimmed.len() == 0
            || trimmed.starts_with("//")
            || trimmed.starts_with("///")
            || trimmed.starts_with("/*!")
        {
            continue;
        }

        // stop before main() as it only contains the assertions
        if trimmed.starts_with("fn main()") {
            break;
        }

        line_number += 1;

        // Get indentation
        let indent = &line[..line.len() - trimmed.len()];

        // Write original code line
        writeln!(output_file, "{} // loc={}", line, line_number).unwrap();

        // If MIR exists, write as block comment
        if let Some(mir_lines) = mir_map.get(&line_number) {
            writeln!(
                output_file,
                "{}/* MIR generated by the above line of Rust code (loc = {}):",
                indent, line_number
            )
            .unwrap();
            for mir in mir_lines {
                writeln!(output_file, "{}{}", indent, mir).unwrap();
            }
            writeln!(output_file, "{}*/", indent).unwrap();
        }
    }

    // Close rust code block
    // writeln!(output_file, "```").unwrap();

    println!("{} {}", "[MIR AUGMENTED]".green(), dest_path.display());
}
